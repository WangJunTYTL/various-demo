@main("Ebean的特性") {
    <div class="container">
        <h1 class="page-header">Ebean的特性如下：</h1>
        <fieldset>
            <legend></legend>
            <pre>

                1、@@Entity(name="EntityName")

                必须,name为可选,对应数据库中一的个表



                2、@@Table(name="",catalog="",schema="")

                可选,通常和@@Entity配合使用,只能标注在实体的class定义处,表示实体对应的数据库表的信息

                name:可选,表示表的名称.默认地,表名和实体名称一致,只有在不一致的情况下才需要指定表名

                catalog:可选,表示Catalog名称,默认为Catalog("").

                schema:可选,表示Schema名称,默认为Schema("").



                3、@@id

                必须

                @@id定义了映射到数据库表的主键的属性,一个实体只能有一个属性被映射为主键.置于getXxxx()前.



                4、@@GeneratedValue(strategy=GenerationType,generator="")

                可选

                strategy:表示主键生成策略,有AUTO,INDENTITY,SEQUENCE 和 TABLE 4种,分别表示让ORM框架自动选择,

                根据数据库的Identity字段生成,根据数据库表的Sequence字段生成,以有根据一个额外的表生成主键,默认为AUTO

                generator:表示主键生成器的名称,这个属性通常和ORM框架相关,例如,Hibernate可以指定uuid等主键生成方式.

                示例:

                @@Id

                @@GeneratedValues(strategy=StrategyType.SEQUENCE)

                public int getPk() {

                return pk;

                }



                5、@@Basic(fetch=FetchType,optional=true)

                可选

                @@Basic表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认即为@@Basic

                fetch: 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER.

                optional:表示该属性是否允许为null,默认为true

                示例:

                @@Basic(optional=false)

                public String getAddress() {

                return address;

                }



                6、@@Column

                可选

                @@Column描述了数据库表中该字段的详细定义,这对于根据JPA注解生成数据库表结构的工具非常有作用.

                name:表示数据库表中该字段的名称,默认情形属性名称一致

                nullable:表示该字段是否允许为null,默认为true

                unique:表示该字段是否是唯一标识,默认为false

                length:表示该字段的大小,仅对String类型的字段有效

                insertable:表示在ORM框架执行插入操作时,该字段是否应出现INSETRT语句中,默认为true

                updateable:表示在ORM框架执行更新操作时,该字段是否应该出现在UPDATE语句中,默认为true.对于一经创建就不可以更改的字段,该属性非常有用,如对于birthday字段.

                columnDefinition:表示该字段在数据库中的实际类型.通常ORM框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将String类型映射到特定数据库的BLOB或TEXT字段类型,该属性非常有用.

                示例:

                @@Column(name="BIRTH",nullable="false",columnDefinition="DATE")

                public String getBithday() {

                return birthday;

                }



                7、@@Transient

                可选

                @@Transient表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.

                如果一个属性并非数据库表的字段映射,就务必将其标示为@@Transient,否则,ORM框架默认其注解为@@Basic

                示例:

                //根据birth计算出age属性

                @@Transient

                public int getAge() {

                return getYear(new Date()) - getYear(birth);

                }



                8、@@ManyToOne(fetch=FetchType,cascade=CascadeType)

                可选

                @@ManyToOne表示一个多对一的映射,该注解标注的属性通常是数据库表的外键

                optional:是否允许该字段为null,该属性应该根据数据库表的外键约束来确定,默认为true

                fetch:表示抓取策略,默认为FetchType.EAGER

                cascade:表示默认的级联操作策略,可以指定为ALL,PERSIST,MERGE,REFRESH和REMOVE中的若干组合,默认为无级联操作

                targetEntity:表示该属性关联的实体类型.该属性通常不必指定,ORM框架根据属性类型自动判断targetEntity.

                示例:

                //订单Order和用户User是一个ManyToOne的关系

                //在Order类中定义

                @@ManyToOne()

                @@JoinColumn(name="USER")

                public User getUser() {

                return user;

                }



                9、@@JoinColumn

                可选

                @@JoinColumn和@@Column类似,介量描述的不是一个简单字段,而一一个关联字段,例如.描述一个@@ManyToOne的字段.

                name:该字段的名称.由于@@JoinColumn描述的是一个关联字段,如ManyToOne,则默认的名称由其关联的实体决定.

                例如,实体Order有一个user属性来关联实体User,则Order的user属性为一个外键,

                其默认的名称为实体User的名称+下划线+实体User的主键名称

                示例:

                见@@ManyToOne



                10、@@OneToMany(fetch=FetchType,cascade=CascadeType)

                可选

                @@OneToMany描述一个一对多的关联,该属性应该为集体类型,在数据库中并没有实际字段.

                fetch:表示抓取策略,默认为FetchType.LAZY,因为关联的多个对象通常不必从数据库预先读取到内存

                cascade:表示级联操作策略,对于OneToMany类型的关联非常重要,通常该实体更新或删除时,其关联的实体也应当被更新或删除

                例如:实体User和Order是OneToMany的关系,则实体User被删除时,其关联的实体Order也应该被全部删除

                示例:

                @@OneTyMany(cascade=ALL)

                public List getOrders() {

                return orders;

                }



                11、@@OneToOne(fetch=FetchType,cascade=CascadeType)

                可选

                @@OneToOne描述一个一对一的关联

                fetch:表示抓取策略,默认为FetchType.LAZY

                cascade:表示级联操作策略

                示例:

                @@OneToOne(fetch=FetchType.LAZY)

                public Blog getBlog() {

                return blog;

                }



                12、@@ManyToMany

                可选

                @@ManyToMany 描述一个多对多的关联.多对多关联上是两个一对多关联,但是在ManyToMany描述中,中间表是由ORM框架自动处理

                targetEntity:表示多对多关联的另一个实体类的全名,例如:package.Book.class

                mappedBy:表示多对多关联的另一个实体类的对应集合属性名称

                示例:

                User实体表示用户,Book实体表示书籍,为了描述用户收藏的书籍,可以在User和Book之间建立ManyToMany关联

                @@Entity

                public class User {

                private List books;

                @@ManyToMany(targetEntity=package.Book.class)

                public List getBooks() {

                return books;

                }

                public void setBooks(List books) {

                this.books=books;

                }

                }



                @@Entity

                public class Book {

                private List users;

                @@ManyToMany(targetEntity=package.Users.class, mappedBy="books")

                public List getUsers() {

                return users;

                }

                public void setUsers(List users) {

                this.users=users;

                }

                }

                两个实体间相互关联的属性必须标记为@@ManyToMany,并相互指定targetEntity属性,

                需要注意的是,有且只有一个实体的@@ManyToMany注解需要指定mappedBy属性,指向targetEntity的集合属性名称

                利用ORM工具自动生成的表除了User和Book表外,还自动生成了一个User_Book表,用于实现多对多关联



                13、@@MappedSuperclass

                可选

                @@MappedSuperclass可以将超类的JPA注解传递给子类,使子类能够继承超类的JPA注解

                示例:

                @@MappedSuperclass

                public class Employee() {

                ....

                }



                @@Entity

                public class Engineer extends Employee {

                .....

                }

                @@Entity

                public class Manager extends Employee {

                .....

                }



                14、@@Embedded

                可选

                @@Embedded将几个字段组合成一个类,并作为整个Entity的一个属性.

                例如User包括id,name,city,street,zip属性.

                我们希望city,street,zip属性映射为Address对象.这样,User对象将具有id,name和address这三个属性.

                Address对象必须定义为@@Embededable

                示例:

                @@Embeddable

                public class Address {city,street,zip}

                @@Entity

                public class User {

                @@Embedded

                public Address getAddress() {

                ..........

                }

                }


            </pre>
        </fieldset>
    </div>
}